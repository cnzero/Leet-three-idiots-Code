Title: #409. Longest Palindrome

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [问题描述](#问题描述)
- [测试样例](#测试样例)
- [解题代码](#解题代码)
  - [S1：奇偶法](#s1奇偶法)
  - [S2：无需区分奇偶](#s2无需区分奇偶)
- [总结感悟](#总结感悟)

<!-- /code_chunk_output -->

#问题描述
给定一个字符串，包含了大小写不同的字母，利用这些字母，使之能凑成一个最长的回文序列，返回该序列的最大长度。
注意，字母的大小写是敏感的，不同的，如 `Aa` 不能形成回文序列。
另，关于回文数列，这个应该不陌生了，从左到右和从右到左的内容一样，也就是左右对称的。
当然，仅仅为了解决该题目，知道这一点就足够了，甚至有一些太多了；而知道太多了，反而妨碍用最接单直白的方法解题。
比如，我上来就想，这多半应该是一个动态规划问题，至少去掉首尾的字母后，仍然是一个回文序列，回到原问题。
然而，本题目只要求返回最大回文序列的长度即可，至于该回文序列是什么内容，大可不必费尽心机算出来；甚至，该回文序列的形式也不止一种。

#测试样例
输入： `abccccdd` ，输出： `7 `
解释：能凑成的最长回文序列可以为 `dccaccd` ，最大长度为`7`.

# 解题代码
## S1：奇偶法
偶：如果某元素的数量为偶数个，则完全加入到该回文序列；
奇：如果某元素的数量为奇数个，则去掉一个数量后为偶数，然后全部加入到该回文序列；
并且，由于是中心对称，实际上中间还是穿插一个元素。
所以，程序如下，比较容易理解。
```Python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        evenChsNums = [s.count(c) for c in set(s) if s.count(c)%2==0]
        oddChsNums = [s.count(c) for c in set(s) if s.count(c)%2]
        
        return sum(evenChsNums) + sum(oddChsNums) - len(oddChsNums) + 1*(oddChsNums!=[])
```

## S2：无需区分奇偶
利用`//2*2` 该运算符，能够取到该数的最大偶数，也就是我们把偶数部分都考虑进来，这些字母一定成为所有回文序列的一部分；
然后按照“奇偶法”的第二步，要不要在中间插入一个元素；
前面考虑的出发点是，奇数部分取出偶数个后，还有没有剩余，有的话，就用一个；
实际上，可以往全局了考虑：把所有的偶数部分（偶数个元素的偶数部分，奇数个元素的最大偶数部分）取进来后，还有没有元素了，有的话，就随便拿过来一个就行了，即 `counts<len(s) `
整体而言，代码又更加简洁了。
```Python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        counts = sum([s.count(c)//2*2 for c in set(s)])
        return counts + 1*(counts<len(s))
```

# 总结感悟
1. 善于利用 // 运算；
2. 保持清醒，不要把问题复杂化了；也不要硬套模型；