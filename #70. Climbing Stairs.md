Title：“#70. Climbing Stairs
其本质模型为一个Fibonacci数列


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [问题描述](#问题描述)
- [测试样例](#测试样例)
- [解题代码](#解题代码)
- [总结与拓展](#总结与拓展)

<!-- /code_chunk_output -->

# 问题描述
爬台阶，n个台阶达到山顶：每次只能前进1步或2步。
问：共计有多少种不同的方法，可以攀登到山顶？
# 测试样例
输入：2，输出：2。解释：1）1step+1step；2）2steps，共计2种方式；
输入：3，输出：3。解释：1）1step+1step+1step；2）1step+2steps；3）2steps+1step，共计3种方式。

# 解题代码
首先简要思考下，这是不是一个DP动态规划问题，似乎是——到达山顶前可以是由最后1步完成，或2步完成；而拆解后，同样是一个类似的最优子问题；所以opt[i]为：
1) 最后走 1步，前面的最优解为opt[i-1]
2) 最后走2步，前面的最优解为opt[i-2]
即，opt[i] = opt[i-1] + opt[i-2]
然后，注意下初始条件即可，完成的代码如下：

```Python
def climbStairs(n):
    opt = [1]*(n+1)
    opt[1] = 1
    for i in range(2, n+1):
        opt[i] = opt[i-1] + opt[i-2]
    return opt[n]
```

再回头看递推公式，或者代码输出结果。这就是Fibonacci数列的本质模型呀。
然后，针对Fibonacci数列，基本上存在三种结题算法：
1. 递推。由大到小，思路直观，但是拆解过程中产生了大量的重复计算，复杂度可达O(2^n)；
2. 循环。有小到大，逐步累加，复杂度为O(n)；
3. 幂方形式。


# 总结与拓展
只要能把问题拆解成“重叠子问题”，题目本身还是比较简单的。这就是动态规划。
其中，比较关键的一点是如何写状态转移方程。

很多时候，动态规划方法比较有意思，比较锻炼逻辑思维。
